import React, { useEffect, useRef } from 'react'

import { fetchLaTeXSvg } from './utils'

import { animate } from './lib/morph'

import gsap from 'gsap'
import MorphSVGPlugin from 'gsap-bonus/MorphSVGPlugin'
import DrawSVGPlugin from 'gsap-bonus/DrawSVGPlugin'

gsap.registerPlugin(MorphSVGPlugin, DrawSVGPlugin)

const positionSvg = (textSvg) => {
  // This function posititions the generated svg of some LaTeX code correctly in the parent svg.

  let [, vy, ,] = textSvg
    .getAttribute('viewBox')
    .split(' ')
    .map((s) => parseFloat(s, 10))
  let width = parseFloat(textSvg.getAttribute('width').replace('pt', ''), 10)
  let height = parseFloat(textSvg.getAttribute('height').replace('pt', ''), 10)

  let { scale, textX, textY } = textSvg.dataset

  const FONT_SCALING_FACTOR = 2
  textX = parseFloat(textX, 10)
  textY = parseFloat(textY, 10)

  // The (x, y) of the text refers to the text anchor.
  // The (x, y) of the svg refers to the top left corner
  // Therefore, as the base line of the svg generated by latex is (0, 0),
  // we translate the svg by vy, keeping in mind the SCALE and the conversion between px and pt (*1.3)

  textSvg.dataset.scale = scale

  textSvg.setAttribute('x', textX)
  textSvg.setAttribute('y', textY + FONT_SCALING_FACTOR * scale * vy * 1.3)
  textSvg.setAttribute('width', FONT_SCALING_FACTOR * scale * width + 'pt')
  textSvg.setAttribute('height', FONT_SCALING_FACTOR * scale * height + 'pt')
}

const replaceText = async (textEle) => {
  // Replace text elements with their LaTeX SVG rendered equivalent
  //
  const text = textEle.textContent
  if (!text) return

  const textSvg = await fetchLaTeXSvg(text)

  if (!textSvg) {
    console.error('No svg for:', textEle, text)
    return
  }

  // To make all text properly sized, we calculate the transformation matrix of the element.
  // It is very important that the element is in the DOM (see (1))
  // Otherwise, getScreenCTM returns null
  const matrix = textEle.getScreenCTM()

  if (!matrix) return

  // Then we undo the scaling We're only using `a`, so we're assuming that the element is not skewed and scale uniformly ...
  // FIXME later?
  // a c e
  // b d f
  // 0 0 1

  let scale = 1 / matrix.a

  textSvg.dataset.textX = textEle.getAttribute('x')
  textSvg.dataset.textY = textEle.getAttribute('y')
  textSvg.dataset.scale = scale

  positionSvg(textSvg)

  const textContentToId = (textContent) =>
    textContent.replace(/[^a-zA-z]+/g, '')

  textSvg.id = textContentToId(textEle.textContent)

  // Finally, we replace the text node with the svg.
  textEle.parentNode.replaceChild(textSvg, textEle)
}

const TIMING = 0.4

// make awaitable?
function update(svg, step, replaceImediately) {
  for (let key in step) {
    if (step[key] === null) {
      continue
    }
    if (key.startsWith('text:')) {
      const id = key.replace(/^text:/, '')
      const textSvg = svg.querySelector(`svg#${id}`)
      if (textSvg) {
        if (replaceImediately) {
          // remove the placeholder of the text
          textSvg.innerHTML = ''
        }
        // TODO: use that animation groups database!
        animate(
          textSvg,
          step[key] || '',
          replaceImediately,
          0.3,
          ({ width, height, viewBox }) => {
            textSvg.setAttribute('width', width + 'pt')
            textSvg.setAttribute('height', height + 'pt')
            textSvg.setAttribute('viewBox', viewBox.join(' '))
            positionSvg(textSvg)
          }
        )
      }
    } else {
      const ele = svg.querySelector(`#${key}`)
      const { css = {}, ...rest } = step[key]
      if (ele) {
        for (let key in css) {
          ele.style[key] = css[key]
        }

        if (replaceImediately) {
          gsap.set(ele, { ...rest })
        } else {
          console.log('timing is ', rest.seconds, TIMING)
          gsap.to(ele, rest.seconds || TIMING, { ...rest })
        }
      }
    }
  }
}

function AnimateSVG({ src, step = {}, width = '100%', height = 'auto' }) {
  const element = useRef(null)
  useEffect(() => {
    ;(async () => {
      // Load the svg
      const text = await fetch(src).then((r) => r.text())
      const div = element.current
      if (!element.current) return
      div.style.opacity = 0
      // (1)
      div.innerHTML = text
      div.querySelector('svg').style.width = width
      div.querySelector('svg').style.height = height

      // Replace text
      await Promise.all(
        [...div.querySelectorAll('text')].map(async (textEle) => {
          if (textEle.matches('.dont-replace *')) {
            return
          }

          // Simply <text></text>
          if (textEle.children.length === 0) {
            await replaceText(textEle)
          } else {
            // Text of the form <text><tspan></tspan> ... <tspan></tspan></text>
            const g = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'g'
            )

            // replace text
            await Promise.all([...textEle.children].map(replaceText))
            // Put the svgs from the replaced text in a group
            ;[...textEle.children].forEach((e) => g.appendChild(e))

            // Replace <text><tspan/><tspan/>...</text> element with <g><svg/><svg/>...</g>
            textEle.parentNode.replaceChild(g, textEle)
          }
        })
      )

      // Set the correct opacity, ... of the elements
      if (element.current) {
        update(element.current, step, true)
      }

      // Fade in the picture
      div.style.transition = '0.3s opacity'
      div.style.opacity = 1
    })()
  }, [element.current])

  // When the step changes, animate the new opacities
  useEffect(() => {
    if (!element.current) return

    update(element.current, step, false)
  }, [step, element])

  return (
    <div
      ref={element}
      style={{
        margin: '-1rem'
      }}
    />
  )
}

export default AnimateSVG
